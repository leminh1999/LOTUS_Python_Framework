# Generated by Selenium IDE
import pytest
import time
import json
import requests
import mysql.connector
import platform
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
# from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.firefox.options import Options

output_dir = "Z:\\YoTu\\Tiktop_Xin_VN\\Output\\"
FIREFOX_HEADLESS = False

MYSQL_IP = "192.168.68.200"
MYSQL_DB = "tiktop_gx"
pc_name_current = platform.uname()[1]


## Kết nối mySQL ##
myDb = mysql.connector.connect(
  host= MYSQL_IP,
  user= "tiktop_"+pc_name_current,
  password= "",
  database= MYSQL_DB, #Tên cơ sở dữ liệu
  autocommit=True #Tự động cập nhật bảng và dữ liệu đang chạy.
)
myCursor = myDb.cursor(dictionary=True) #=> Xuất dữ liệu dạng dictionary (Giống object)

myDbZalo = mysql.connector.connect(
  host= MYSQL_IP,
  user= 'tiktop_'+pc_name_current,
  password= '',
  database= 'zalo_bot', #Tên cơ sở dữ liệu
  autocommit=True #Tự động cập nhật bảng và dữ liệu đang chạy.
)
myCursorZalo = myDbZalo.cursor(dictionary=True) #=> Xuất dữ liệu dạng dictionary (Giống object)


class dataInfo ():
  #Config
  cfg00_ena = 1
  cfg00_key_check_num = 0
  
  #Key list
  key10_id        = 0
  key10_key_word  = ""
  key10_key_type  = ""
  key10_scan_time = 0
  key10_total_num = 0
  
  #Current process data
  cur_key_list_id = 0
  cur_key_word    = ""
  cur_key_type    = ""
  cur_scan_time   = 0
  cur_total_num   = 0
  cur_video_id    = ""
  cur_video_link  = ""
  cur_status      = ""
  
  
  
  

class Test():
  #Chrome
  def setup_method(self,browserChromeOrFirefox = 'Chrome',headless=False):
    if browserChromeOrFirefox == 'Chrome':
      options = webdriver.ChromeOptions()
      options.add_argument('disable-infobars')
      options.add_argument('--no-sandbox') # Bypass OS security model
      options.add_argument('--disable-gpu')  # applicable to windows os only
      options.add_argument('start-maximized') # 
      options.add_argument("--disable-extensions")
      if headless == True: options.add_argument("--headless") # Runs Chrome in headless mode.
      self.driver = webdriver.Chrome(options=options)
    else:
      options = webdriver.FirefoxOptions()
      options.add_argument('--no-sandbox') # Bypass OS security model
      options.add_argument('--disable-gpu')  # applicable to windows os only
      options.add_argument('start-maximized') # 
      options.add_argument("--disable-extensions")
      if headless == True: options.add_argument("--headless") # Runs Chrome in headless mode.
      self.driver = webdriver.Firefox(options=options)

    self.wait = WebDriverWait(self.driver, 20, poll_frequency=1,
                              ignored_exceptions=[])
    self.url = "https://www.tiktok.com/@promise0069/video/7000222710496234778"
    self.video_name = "jubei_video"
    self.videoSavePath = output_dir+self.video_name
  
  def teardown_method(self):
    self.driver.quit()
  
  def downloadVideo(self):
    n = 0
    LOOP_NUM = 1
    while n < LOOP_NUM:
      print("DEBUG: "+str(n))
      startTime = time.time()
      n += 1
      #1. Input video link
      self.driver.get("https://ssstik.io/")
      # self.driver.set_window_size(967, 667)
      text_url = self.wait.until(EC.presence_of_element_located((By.ID, "main_page_text")))
      text_url.send_keys(self.url)
      text_submit = self.driver.find_element_by_id('submit')
      text_submit.click()
      # Kiểm tra xem có bị lỗi do liên tục requests không.
      try:
        time.sleep(4)
        self.driver.find_element_by_class_name("pure-u-22-24")
        text_submit.click()
      except:
        pass
      
      #2. Click download video no watermark link
      no_watermark_button = self.wait.until(
          lambda x: x.find_element_by_xpath("//*[contains(text(), 'Without watermark [2]')]"))
      no_watermark_button.click()

      #3. Get no watermark video link
      main_handler = self.driver.current_window_handle
      video_url = None
      for handle in self.driver.window_handles:
          if handle != self.driver.current_window_handle:
              self.driver.switch_to.window(handle)
              self.wait.until(
                  lambda x: 'blank' not in x.current_url)
              video_url = self.driver.current_url
              self.driver.close()
              self.driver.switch_to.window(main_handler)
              break

      #4. Download video
      try:
        kwargs = {'allow_redirects': True}
        r = requests.get(video_url, **kwargs)
        with open(f'{self.videoSavePath}.mp4', "wb") as f:
            f.write(r.content)
        # self.driver.close()
      except:
        pass
      
      #5. Delay to make sure 1 tour is around 20 seconds
      if n != LOOP_NUM:
        deltaTime = 20 - (time.time()-startTime)
        if deltaTime > 0:
          time.sleep(deltaTime)

  def test_scanSearchList(self,keywords):
    self.driver.get("https://www.tiktok.com/search?q="+keywords)

    lastClipNum = 0
    clipNum = 0
    while True:
      try:
        loadMoreButtonElement = WebDriverWait(self.driver, 15).until(EC.presence_of_element_located((By.CLASS_NAME, "e1v5onft1"))) # Images/2b.png
        # clipNum = len(self.driver.page_source.replace('\n','').split('DivItemContainerForSearch')) - 1
        clipNum = len(self.driver.find_elements(By.CLASS_NAME,'tiktok-duhy92-DivItemContainerForSearch'))
        # print(clipNum)
        loadMoreButtonElement.click()
        
        # print("Clip num: "+str(clipNum))
        if clipNum != lastClipNum:
          lastClipNum = clipNum
        else:
          print("Exit due to infinite loop (Load and Click ButtonMore) -> End Searching")
          break
        
      except Exception as errMessage:
        print(errMessage)
        print("Time out -> End Searching")
        break
    dataInfo.cur_total_num = clipNum

  def test_scanTagList(self,keywords):
    self.driver.get("https://www.tiktok.com/tag/"+keywords)
    n = 1
    scrollPos = 0
    lastListClipNum = 0
    while True:
    # while n == 1:
      # n = 2
      try:
        scrollPos += 2000
        self.driver.execute_script("window.scrollTo(0,"+str(scrollPos)+")")
        listClipNum = len(app.driver.find_elements(By.CLASS_NAME,'video-card-mask'))
        if lastListClipNum != listClipNum:
          print(listClipNum)
          lastListClipNum = listClipNum
          continue
        else:
          break
      except Exception as errMessage:
        print("Time out -> End Searching")
        break
    
  def downloadAllVideo(self):
    n = 1
    retryDownload = 0
    LOOP_NUM = 1
    while n <= LOOP_NUM or retryDownload == 1:
      print("DEBUG: "+str(n))
      startTime = time.time()
      #1. Input video link
      self.driver.get("https://ssstik.io/")
      # self.driver.set_window_size(967, 667)
      text_url = self.wait.until(EC.presence_of_element_located((By.ID, "main_page_text")))
      text_url.send_keys(self.url)
      text_submit = self.driver.find_element_by_id('submit')
      text_submit.click() # Images/3b.png (2). Click nút submit link video
      # Kiểm tra xem có bị lỗi do liên tục requests không.
      try:
        time.sleep(4)
        self.driver.find_element_by_class_name("pure-u-22-24") # Images/3b.png (1). Thông báo đợi do request liên tục.
        text_submit.click() # Images/3b.png (2). Click nút submit link video lần thứ 2.
        time.sleep(4)
        self.driver.find_element_by_class_name("pure-u-22-24") # Images/3b.png (1). Thông báo đợi do request liên tục.
        text_submit.click() # Images/3b.png (2). Click nút submit link video lần thứ 3.
      except:
        pass #Exception khi không có thông báo lỗi bắt đợi ở Images/3b.png (1)
      
      #2. Click download video no watermark link
      no_watermark_button = self.wait.until(
          lambda x: x.find_element_by_xpath("//*[contains(text(), 'Without watermark [2]')]")) # Images/4b.png. Nút tải không có watermark.
      no_watermark_button.click()

      #3. Get no watermark video link
      main_handler = self.driver.current_window_handle
      video_url = None
      for handle in self.driver.window_handles:
          if handle != self.driver.current_window_handle:
              self.driver.switch_to.window(handle)
              self.wait.until(
                  lambda x: 'blank' not in x.current_url)
              video_url = self.driver.current_url
              self.driver.close()
              self.driver.switch_to.window(main_handler)
              break

      #4. Download video
      try:
        kwargs = {'allow_redirects': True}
        r = requests.get(video_url, **kwargs)
        with open(f'{self.videoSavePath}.mp4', "wb") as f:
            f.write(r.content) #Lưu video lại nếu có cửa sổ video mở ra.
        retryDownload = 0
      except: 
        if retryDownload == 0:
          retryDownload = 1 #Khi có cửa sổ mở ra nhưng không có video -> Retry lại 1 lần nữa.
        else:
          retryDownload = 0 #Chỉ cho Retry lại 1 lần duy nhất.
      #5. Delay to make sure 1 tour is around 20 seconds
      if n != LOOP_NUM:
        deltaTime = 20 - (time.time()-startTime)
        if deltaTime > 0:
          time.sleep(deltaTime)
          
      #6. Kiểm tra tăng loop
      if retryDownload == 0:
        n += 1


  def loadConfigGx(self):
    '''
    =============================================================================
    Function: Load các cấu hình của MySQL về class dataInfo
    Parameter: None
    Ruturn: None
    =============================================================================
    '''
    #1. Load MySQL table config (00)
    sql = "SELECT * FROM vn_00_config LIMIT 1"
    myCursor.execute(sql)
    readData = myCursor.fetchall()
    dataInfo.cfg00_ena = readData[0]['ena']
    dataInfo.cfg00_key_check_num = readData[0]['key_check_num']

    #2. Load MySQL table key list (10)
    sql = "SELECT * FROM vn_10_key_list"
    myCursor.execute(sql)
    readData = myCursor.fetchall()
    
    self.maxList = len(readData)
    i = dataInfo.cfg00_key_check_num
    if i <= self.maxList:
      pass
    else:
      i = self.maxList
    dataInfo.key10_id        = dataInfo.cur_key_list_id = readData[i-1]['id']
    dataInfo.key10_key_word  = dataInfo.cur_key_word    = readData[i-1]['key_word']
    dataInfo.key10_key_type  = dataInfo.cur_key_type    = readData[i-1]['key_type']
    dataInfo.key10_scan_time = dataInfo.cur_scan_time   = readData[i-1]['scan_time']
    dataInfo.key10_total_num = dataInfo.cur_total_num   = readData[i-1]['total_num']

      
    #DEBUG
    # print(dataInfo.key10_key_word)
    # print(dataInfo.key10_key_type)
    
  def appendScanList(self, videoLink, videoId):
    '''
    =============================================================================
    Function: Cập nhật lên scanList nếu thông tin về clip chưa tồn tại
    Parameter: None
    Ruturn: None
    =============================================================================
    '''
    #Kiểm tra dữ liệu tren MySQL và INSERT nếu dòng chưa có
    sql = "SELECT * FROM vn_20_scanned_list WHERE video_id = '"+str(videoId)+"' LIMIT 1"
    myCursor.execute(sql)
    readData = myCursor.fetchall()
    
    if len(readData) > 0: #Đã tồn tại
      pass
    else: #Chưa có trên MySQL -> INSERT
        sql = "INSERT INTO vn_20_scanned_list (video_id,video_link,key_word,key_type,status) VALUES (%s,%s,%s,%s,%s)"
        val = (str(videoId),str(videoLink),dataInfo.cur_key_word,dataInfo.cur_key_type,"-999")
        myCursor.execute(sql, val)
        myDb.commit()
  
  def clearTable (self,tableName):
    '''
    =============================================================================
    Function: Xóa toàn bộ nội dung trong bảng
    Parameter: tableName: Tên bảng cần xóa
    Ruturn: None
    Ex: 
    =============================================================================
    '''
    #1. Before clear
    sql = "SELECT * FROM "+str(tableName)
    myCursor.execute(sql)
    readData = myCursor.fetchall()
    print("+ Before Clear: "+str(len(readData))+" rows")
    #2. Clear table
    sql = "DELETE FROM "+str(tableName)
    myCursor.execute(sql)
    myDb.commit()
    #3. After clear
    sql = "SELECT * FROM "+str(tableName)
    myCursor.execute(sql)
    readData = myCursor.fetchall()
    print("+ After Clear : "+str(len(readData))+" rows")
    

#####################################################################################
#####################################################################################
#####################################################################################
app = Test()
app.loadConfigGx()

# app.clearTable("vn_30_downloaded_list")
# exit()

app.setup_method('Chrome',headless=False)
print('\n====================================================\n')

#1. Quét dữ liệu và cập nhật vào Scanned list
# try:
#   if dataInfo.cur_key_type == "search":
#     app.test_scanSearchList(keywords=dataInfo.cur_key_word)
    
#   listClip = app.driver.find_elements(By.CLASS_NAME,'tiktok-duhy92-DivItemContainerForSearch') # Images/1b.png
#   print(len(listClip))
#   for eachClip in listClip:
#     # EX: https://www.tiktok.com/@cartoon_5_world/video/7013098852551052546
#     clipLink = eachClip.find_element(By.TAG_NAME,'a').get_attribute('href')
#     dataInfo.cur_video_link = clipLink
#     dataInfo.cur_video_id = clipLink.split('/video/')[1]
#     # print(dataInfo.cur_video_id)
#     # print(dataInfo.cur_video_link)
    
#     #Upload Scan list
#     app.appendScanList(dataInfo.cur_video_link,dataInfo.cur_video_id)
# except:
#   print("Có lỗi Scanned List")
# finally:
#   #Tăng giá trị scan trong table config
#   checkNum = dataInfo.cfg00_key_check_num
#   checkNum += 1
#   if checkNum > app.maxList:
#     checkNum = 1
#   #Cập nhật MySQL: Config table
#   sql = "UPDATE vn_00_config SET key_check_num = "+str(checkNum)+" WHERE id = 1"
#   myCursor.execute(sql)
#   myDb.commit()
#   #Cập nhật MySQL: key_list table
#   dataInfo.cur_scan_time += 1
#   sql = "UPDATE vn_10_key_list SET scan_time = "+str(dataInfo.cur_scan_time)+", total_num = "+str(dataInfo.cur_total_num)+" WHERE id = "+str(dataInfo.cur_key_list_id)
#   myCursor.execute(sql)
#   myDb.commit()
  
  
#2. Tải video không watermark từ scanlist và cập nhật vn_30_downloaded_list
app.downloadAllVideo()






# app.test_scanTagList(keywords="cartoon")
# listClip = app.driver.find_elements(By.CLASS_NAME,'video-card-mask')
# print(len(listClip))
# for eachClip in listClip:
#   clipLink = eachClip.find_element(By.TAG_NAME,'a').get_attribute('href')
#   print(clipLink)

app.driver.close()
app.driver.quit()