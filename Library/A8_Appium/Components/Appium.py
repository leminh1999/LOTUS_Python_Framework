# Generated by Selenium IDE
import __init
import time
import json
from Conf.loggingSetup import *
from appium import webdriver # Nh·∫≠p th∆∞ vi·ªán appium
import random



from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.remote.webelement import WebElement
from selenium.common.exceptions import NoSuchElementException
from selenium.common.exceptions import TimeoutException
from Library.A2_LOTUS.Components.LotusLib import LotusLib
from selenium.webdriver.common.actions.pointer_input import PointerInput
from selenium.webdriver.common.actions import interaction
from selenium.webdriver.common.actions.action_builder import ActionBuilder
from selenium.webdriver.common.keys import Keys








class AppiumLib ():
  exitOnExceptionFlg = True #Khi g·∫∑p exception s·∫Ω Exit
  defaultWaitTimeMs = "30000" #Default timeout of Wait For commands in ms
  # vars = {}
  printOutEna = True
  printOutLevel = "Debug" #8 levels: Fatal/Error/Warn/Info/Debug/Trace/Terminal/NoPrint
  commandNum = 0          #Counter of Selenium commands
  # browserTabList = []     #List of browser tab name. Call refreshBrowserTabInfo to update.
  # browserTabHandle = []   #List of browser tab handle name. Call refreshBrowserTabInfo to update.
  # browserTabNum = 0       #Number of browser tab. Call refreshBrowserTabInfo to update.
  reqWaitCmdFlg = False   #C·ªù y√™u c·∫ßu l·ªánh ti·∫øp theo l√† m·ªôt l·ªánh ch·ªù (Sau m·ªôt l·ªánh action).
  
  def __init__(self):
    desired_caps = {
        "uuid": "no info",                             # üî¥ ID c·ªßa m√°y ·∫£o/ƒëi·ªán tho·∫°i th·∫≠t. L·∫•y b·∫±ng l·ªánh "adb devices"
        "platformName": "Android",                     # üî¥ T√™n h·ªá ƒëi·ªÅu h√†nh
        'newCommandTimeout': int(300),                 # üî¥ Appium Server s·∫Ω kill session n·∫øu client kh√¥ng g·ª≠i request trong 300s
    }
    self.driver = webdriver.Remote("http://localhost:4723/wd/hub", desired_caps) # Kh·ªüi t·∫°o m·ªôt session v·ªõi desired_caps
    self.WIDTH = 0
    self.HEIGHT = 0
    return
  
  # def begin (self, remoteAddr:str="localhost",remotePort:int=4723,desired_caps:dict={}):
  #   self.driver = webdriver.Remote("http://"+remoteAddr.strip()+":"+str(remotePort)+"/wd/hub", desired_caps) # Kh·ªüi t·∫°o m·ªôt session v·ªõi desired_caps
  #   self.driver.implicitly_wait(30) # C√†i ƒë·∫∑t th·ªùi gian ch·ªù cho element hi·ªÉn th·ªã (VD: trong 30s)
  #   deviceResolution = self.driver.get_window_size()
  #   self.WIDTH = deviceResolution['width']
  #   self.HEIGHT = deviceResolution['height']
  
  def begin (self, remoteAddr:str="",remotePort:int=4723,deviceUUID:str="adb devices", platformName:str="Android", newCommandTimeout:int=300, appPackage:str="", appActivity:str="",implicitlyWait:int=30,desired_caps:dict={}):
    if desired_caps == {}:
      desired_caps = {
          "uuid": deviceUUID,                          # üî¥ ID c·ªßa m√°y ·∫£o/ƒëi·ªán tho·∫°i th·∫≠t. L·∫•y b·∫±ng l·ªánh "adb devices"
          "platformName": platformName,                   # üî¥ T√™n h·ªá ƒëi·ªÅu h√†nh
          'newCommandTimeout': int(newCommandTimeout), # üî¥ Appium Server s·∫Ω kill session n·∫øu client kh√¥ng g·ª≠i request trong 300s
          # 'appPackage': appPackage,                    # ‚õîCH√ö √ù: Khi g·∫Øn appPackage v√† appActivity th√¨ c√°c icon tr√™n m√†n h√¨nh s·∫Ω b·ªã k√©o v·ªÅ v·ªã tr√≠ g·ªëc c·ªßa n√≥.
          # 'appActivity': appActivity                   # ‚õîS·∫Ω thay ƒë·ªïi v·ªã tr√≠ v√† th∆∞ m·ª•c m√† USER ƒë√£ s·∫Øp x·∫øp tr√™n m√†n h√¨nh
      }
    self.driver = webdriver.Remote("http://"+remoteAddr.strip()+":"+str(remotePort)+"/wd/hub", desired_caps) # Kh·ªüi t·∫°o m·ªôt session v·ªõi desired_caps
    self.driver.implicitly_wait(implicitlyWait) # C√†i ƒë·∫∑t th·ªùi gian ch·ªù cho element hi·ªÉn th·ªã (VD: trong 30s)
    deviceResolution = self.driver.get_window_size()
    self.WIDTH = deviceResolution['width']
    self.HEIGHT = deviceResolution['height']
    
  def quit (self):
    self.driver.quit()
    
  ##############################################
  ################ HARD BUTTON #################
  ##############################################
  def buttonHome (self):
    self.driver.press_keycode(3)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Press HOME button"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\pressButton.png",rowIndex=logger.rowCnt%2)
  
  def buttonBack (self):
    self.driver.press_keycode(4)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Press BACK button"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\pressButton.png",rowIndex=logger.rowCnt%2)

  def buttonVolumeUp (self):
    self.driver.press_keycode(24)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Press VOLUME UP button"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\pressButton.png",rowIndex=logger.rowCnt%2)
  
  def buttonVolumeDown (self):
    self.driver.press_keycode(25)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Press VOLUME DOWN button"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\pressButton.png",rowIndex=logger.rowCnt%2)

  def buttonVolumeMute (self):
    self.driver.press_keycode(164)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Press VOLUME MUTE button"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\pressButton.png",rowIndex=logger.rowCnt%2)

  def buttonPower (self):
    self.driver.press_keycode(26)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Press POWER button"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\pressButton.png",rowIndex=logger.rowCnt%2)
  
  ##############################################
  ################ FUNC BUTTON #################
  ##############################################
  def funcSleep (self):
    self.driver.press_keycode(223)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Sleep"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcWakeUp (self):
    self.driver.press_keycode(224)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Weakup From Sleep"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcCopy (self):
    self.driver.press_keycode(278)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Copy"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcPaste (self):
    self.driver.press_keycode(279)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Paste"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcCut (self):
    self.driver.press_keycode(277)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Cut"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcPageDown (self):
    self.driver.press_keycode(93)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Page Down"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcPageUp (self):
    self.driver.press_keycode(92)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Page Up"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcEnterKey (self):
    self.driver.press_keycode(66)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Enter"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def buttonBack (self):
    self.driver.press_keycode(4)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Back"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def buttonForward (self):
    self.driver.press_keycode(125)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Forward"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcInputSearch (self):
    self.driver.press_keycode(84)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Search"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcOpenCallApp (self):
    self.driver.press_keycode(5)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Call App"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcEndCall (self):
    self.driver.press_keycode(6)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call End Call"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcOpenBrowserApp (self):
    self.driver.press_keycode(64)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Open Browser"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcOpenMailApp (self):
    self.driver.press_keycode(65)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Mail App"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcAppSwitch (self):
    self.driver.press_keycode(187)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call App Switch"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcShowAllApp (self):
    self.driver.press_keycode(284)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Show All Apps"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcBrightnessUp (self):
    self.driver.press_keycode(221)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Brightness Up"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcBrightnessDown (self):
    self.driver.press_keycode(220)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Brightness Down"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcOpenCalendarApp (self):
    self.driver.press_keycode(208)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Calendar App"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcOpenMusicApp (self):
    self.driver.press_keycode(209)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Music App"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcOpenContactApp (self):
    self.driver.press_keycode(207)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Contact App"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcCameraZoomIn (self):
    self.driver.press_keycode(168)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Camera Zoom In"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcCameraZoomOut (self):
    self.driver.press_keycode(169)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Camera Zoom Out"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  def funcCameraCaptureButton (self):
    self.driver.press_keycode(27)
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". Call Camera Capture"+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\swFunc.png",rowIndex=logger.rowCnt%2)
    
  ##############################################
  ################## FINGER ####################
  ##############################################
  def tapPos (self, x:int, y:int, durationMs:int=100):
    commandName = "tapPos" #<--- FUNCTION NAME
    self.commandNum += 1
    command = "<APPIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"(x,y=["+str(x)+","+str(y)+"], durationMs="+str(durationMs)+")"
    
    logger.allowLogging  = False #Skip logging from now on
    self.__printCmdDes(command)
    logger.allowLogging  = True # Allow logging from now on
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    # Appium fullscreen capture
    self.driver.save_screenshot("TapPosFSscreenshot.png")
    fileName = "TapPos_"+"x"+str(x)+"_y"+str(y)+"_"+str(random.randint(0,999999))+".png"
    FILE_PATH = HTML_LOG_DIR+"/data/"+fileName
    LotusLib.saveClickImage(xPos=x, yPos=y,imagePath="TapPosFSscreenshot.png", radius=100, borderColor=(255,0,0), borderWidth=10 , printPosInside=True ,savePath=FILE_PATH)
    os.remove("TapPosFSscreenshot.png")
    LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> (x,y=["+str(x)+","+str(y)+"], durationMs="+str(durationMs)+")",mediaPath=FILE_PATH,rowIndex=logger.rowCnt%2)
    self.driver.tap([(x,y)], durationMs)
  
  def tapMultiPos (self, posListTuple:list, durationMs:int=100):
    self.driver.tap(posListTuple, durationMs)
  
  ###########################
  ### 3.1 tap             ###
  ###########################
  def findElement (self,target=""):
    if target.startswith("xpath="):    return self.driver.find_element(By.XPATH            ,target[len("xpath="):]   )
    if target.startswith("tag="):      return self.driver.find_element(By.TAG_NAME         ,target[len("tag="):]     )
    if target.startswith("class="):    return self.driver.find_element(By.CLASS_NAME       ,target[len("class="):]   )
    if target.startswith("id="):       return self.driver.find_element(By.ID               ,target[len("id="):]      )
    if target.startswith("name="):     return self.driver.find_element(By.NAME             ,target[len("name="):]    )
    if target.startswith("css="):      return self.driver.find_element(By.CSS_SELECTOR     ,target[len("css="):]     )
    if target.startswith("link="):     return self.driver.find_element(By.LINK_TEXT        ,target[len("link="):]    )
    if target.startswith("partLink="): return self.driver.find_element(By.PARTIAL_LINK_TEXT,target[len("partLink="):])
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'

  def __printCmdDes (self,command="",description="",printCmd=True):
    if description != "": description = "//"+description
    if self.printOutEna == True and self.printOutLevel == "Fatal"   : logger.fatal("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Error"   : logger.error("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Warn"    : logger.warn ("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Info"    : logger.info ("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Debug"   : logger.debug("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Trace"   : logger.trace("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Terminal": print ("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "NoPrint" : return
    
  def others_browser_findChildElement(self,element:WebElement,xpath,description="",printCmd=True):
    '''=================================================================
    + Name: others_browser_scrollToElement
    + Function: T√¨m ƒë·∫øn element con c·ªßa m·ªôt element cha n√†o ƒë√≥.
    + Parameter:
      - element: Element cha.
      - xpath: ƒë∆∞·ªùng d·∫´n xpath.
      - description: Description will be printed out
    + Return:
      - True: element con ƒë∆∞·ª£c t√¨m th·∫•y
      - False: None\n
    ================================================================='''
    #Print command and description
    commandName = "others_browser_scrollToElement" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"(Element,"+str(xpath)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      if "xpath" in xpath:
        return element.find_element(By.XPATH,"./child::"+xpath[len("xpath="):])
      else:
        raise Exception(">>> TARGET PARAMETER MUST BE XPATH <<<")
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("CANNOT FIND CHILD ELEMENT. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      
  def others_browser_findChildElements(self,element:WebElement,xpath,description="",printCmd=True):
    '''=================================================================
    + Name: others_browser_findChildElements
    + Function: T√¨m ƒë·∫øn c√°c element con c·ªßa m·ªôt element cha n√†o ƒë√≥.
    + Parameter:
      - element: Element cha.
      - xpath: ƒë∆∞·ªùng d·∫´n xpath. EX: xpath="xpath=//div[@class='abc']"
      - description: Description will be printed out
    + Return:
      - True: List of all elements
      - False: None\n
    ================================================================='''
    #Print command and description
    commandName = "others_browser_findChildElements" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"(Element,"+str(xpath)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      if "xpath" in xpath:
        return element.find_elements(By.XPATH,"./child::"+xpath[len("xpath="):])
      else:
        raise Exception(">>> TARGET PARAMETER MUST BE XPATH <<<")
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("CANNOT FIND CHILD ELEMENT. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      
  def tap(self,target="",value="",description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è tap
    + Function: Tap is to click on any UI element in the application.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: None
      - description: Description will be printed out
    + Return:
      - element n·∫øu c√≥ t·ªìn t·∫°i element ƒë·ªÉ tap.
      - None: N·∫øu kh√¥ng t·ªìn t·∫°i element ƒë·ªÉ tap.\n
    ================================================================='''
    #Print command and description
    commandName = "tap" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<APPIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    # if self.reqWaitCmdFlg == True:
    #   logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
    #   exit()
    
    #Function operation
    try:
      # print(target)
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
        
      # Add element and text to html log
      try:
        resourceId = element.get_attribute("resource-id")
        if resourceId == None:
          resourceId = element.id
      except:
        resourceId = str(random.randint(0,999999))
      resourceId = resourceId.replace("/","_").replace(":","_").replace(".","_")
      FILE_PATH = str(resourceId)+".png"
      element.screenshot(FILE_PATH)
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , "+str(value)+")",mediaPath=FILE_PATH,rowIndex=logger.rowCnt%2)
      os.remove(FILE_PATH)
      
      element.click()
      self.reqWaitCmdFlg = True
      return element
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      return None
    
  ###########################
  ### 3.2 double tap      ###
  ###########################
  def doubleTap(self,target="",value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è doubleTap
    + Function: The purpose of double tap command in Selenium IDE, is to double tap on any UI element.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: None
      - description: Description will be printed out
    + Return:
      - element n·∫øu c√≥ t·ªìn t·∫°i element ƒë·ªÉ tap.
      - None: N·∫øu kh√¥ng t·ªìn t·∫°i element ƒë·ªÉ tap.\n
    ================================================================='''
    #Print command and description
    commandName = "doubleTap" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<APIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    # if self.reqWaitCmdFlg == True:
    #   logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
    #   exit()
    
    #Function operation
    try:
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
        
      # Add element and text to html log
      try:
        resourceId = element.get_attribute("resource-id")
        if resourceId == None:
          resourceId = element.id
      except:
        resourceId = str(random.randint(0,999999))
      resourceId = resourceId.replace("/","_").replace(":","_").replace(".","_")
      FILE_PATH = str(resourceId)+".png"
      element.screenshot(FILE_PATH)
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , "+str(value)+")",mediaPath=FILE_PATH,rowIndex=logger.rowCnt%2)
      os.remove(FILE_PATH)
      
      actions = ActionChains(self.driver)
      actions.double_click(element).perform()
      self.reqWaitCmdFlg = True
      return element
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      return None
  
  ###########################
  ### 3.3 longTap         ###
  ###########################
  def longTap(self,target="",value="1000" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è longTap
    + Function: nh·∫•n v√† gi·ªØ l√¢u ƒë·ªëi t∆∞·ª£ng tr√™n m√†n h√¨nh.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: th·ªùi gian gi·ªØ l√¢u ƒë·ªëi t∆∞·ª£ng. M·∫∑c ƒë·ªãnh l√† 1000ms.
      - description: Description will be printed out
    + Return:
      - element n·∫øu c√≥ t·ªìn t·∫°i element ƒë·ªÉ tap.
      - None: N·∫øu kh√¥ng t·ªìn t·∫°i element ƒë·ªÉ tap.\n
    ================================================================='''
    #Print command and description
    commandName = "longTap" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<APPIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    # if self.reqWaitCmdFlg == True:
    #   logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
    #   exit()
    
    #Function operation
    try:
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
        
        
      # Add element and text to html log
      try:
        resourceId = element.get_attribute("resource-id")
        if resourceId == None:
          resourceId = element.id
      except:
        resourceId = str(random.randint(0,999999))
      resourceId = resourceId.replace("/","_").replace(":","_").replace(".","_")
      FILE_PATH = str(resourceId)+".png"
      element.screenshot(FILE_PATH)
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , "+str(value)+")",mediaPath=FILE_PATH,rowIndex=logger.rowCnt%2)
      os.remove(FILE_PATH)
        
      actions = ActionChains(self.driver)
      actions.click_and_hold(element)
      actions.pause(int(value)/1000)
      actions.release(element).perform()
      self.reqWaitCmdFlg = True
      return element
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      return None
  
  ################################
  ### 3.4 dragDrop             ###
  ################################
  def dragDrop(self,target="",value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è dragDrop
    + Function: The purpose of drag and drop to object command in Selenium IDE, is to drag an UI element and drop it at another UI element.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element c·∫ßn ch·ªçn. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: Tr·ªè ƒë·∫øn element c·∫ßn ƒë·∫øn. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - description: Description will be printed out
    + Return:
      - draggedElement,droppedElement n·∫øu c√≥ t·ªìn t·∫°i elements.
      - None: N·∫øu kh√¥ng t·ªìn t·∫°i element..\n
    ================================================================='''
    #Print command and description
    commandName = "dragDrop" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<APPIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    # if self.reqWaitCmdFlg == True:
    #   logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
    #   exit()
    
    #Function operation
    try:
      if element == None:
        draggedElement = self.findElement(target)
        droppedElement = self.findElement(value)
      else:
        draggedElement = self.others_browser_findChildElement(element,target,"",False)
        droppedElement = self.findDedicatedElement(element,value)
      actions = ActionChains(self.driver)
      actions.drag_and_drop(draggedElement,droppedElement).perform()
      self.reqWaitCmdFlg = True
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , "+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\ActionIcon.png",rowIndex=logger.rowCnt%2)
      return draggedElement,droppedElement
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      return None

  ################################
  ### 3.5 longTapDragDrop      ###
  ################################
  def longTapDragDrop(self,target="",value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è longTapDragDrop
    + Function: Nh·∫•n gi·ªØ l√¢u (1 gi√¢y) v√†o 1 element v√† k√©o th·∫£ ƒë·∫øn 1 element kh√°c.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element c·∫ßn ch·ªçn. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: Tr·ªè ƒë·∫øn element c·∫ßn ƒë·∫øn. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - description: Description will be printed out
    + Return:
      - draggedElement,droppedElement n·∫øu c√≥ t·ªìn t·∫°i elements.
      - None: N·∫øu kh√¥ng t·ªìn t·∫°i element..\n
    ================================================================='''
    #Print command and description
    commandName = "longTapDragDrop" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<APPIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    # if self.reqWaitCmdFlg == True:
    #   logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
    #   exit()
    
    #Function operation
    try:
      if element == None:
        draggedElement = self.findElement(target)
        droppedElement = self.findElement(value)
      else:
        draggedElement = self.others_browser_findChildElement(element,target,"",False)
        droppedElement = self.findDedicatedElement(element,value)
      actions = ActionChains(self.driver)
      actions.click_and_hold(draggedElement)
      actions.pause(1)
      actions.release(droppedElement)
      actions.perform()
      self.reqWaitCmdFlg = True
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , "+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\ActionIcon.png",rowIndex=logger.rowCnt%2)
      return draggedElement,droppedElement
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      return None
    
  ################################
  ### 3.6 scroll               ###
  ################################
  def scroll(self,fromObj="Tr·ªè ƒë·∫øn Element/Tuple(x,y)",toObj="Tr·ªè ƒë·∫øn Element/Tuple(x,y)" ,description="",printCmd=True,durationMs:int = 200):
    '''=================================================================
    + Name: scroll (‚ö†Ô∏èüö® Action command -> Next command is WaitFor type)
    + Function: cu·ªôn m√†n h√¨nh t·ª´ v·ªã tr√≠ fromObj ƒë·∫øn v·ªã tr√≠ toObj.
    + Parameter:
      - fromObj:
              [1] Tuple (x,y) t∆∞∆°ng ƒë·ªëi so v·ªõi v·ªã tr√≠ hi·ªán t·∫°i c·ªßa m√†n h√¨nh. Ex: (50,100)
              [2] Tr·ªè ƒë·∫øn element c·∫ßn ch·ªçn. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - toObj:
              [1] Tuple (x,y) t∆∞∆°ng ƒë·ªëi so v·ªõi v·ªã tr√≠ hi·ªán t·∫°i c·ªßa m√†n h√¨nh. Ex: (50,100)
              [2] Tr·ªè ƒë·∫øn element c·∫ßn ch·ªçn. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - description: Description will be printed out
    + Return: None.\n
    ================================================================='''
    #Print command and description
    commandName = "scroll" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<APPIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(fromObj)+" , "+str(toObj)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
        
    try:
      touch_input = PointerInput(interaction.POINTER_TOUCH, "touch")
      actions = ActionChains(self)
      actions.w3c_actions = ActionBuilder(self, mouse=touch_input)
      if type(fromObj) == tuple:
        x = fromObj[0]
        y = fromObj[1]
        actions.w3c_actions.pointer_action.move_to(x=x, y=y)
      else:
        actions.w3c_actions.pointer_action.move_to(fromObj)
      actions.w3c_actions.pointer_action.pointer_down()
      # setup duration for second move only, assuming duration always has atleast default value
      actions.w3c_actions = ActionBuilder(self, mouse=touch_input, duration=durationMs)
      if type(toObj) == tuple:
        x = toObj[0]
        y = toObj[1]
        actions.w3c_actions.pointer_action.move_to(x=x, y=y)
      else:
        actions.w3c_actions.pointer_action.move_to(toObj)
      actions.w3c_actions.pointer_action.release()
      actions.perform()
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> (From "+str(fromObj)+" ,To "+str(toObj)+")",mediaPath="Logs\RotateLogs\htmlAsset\ActionIcon.png",rowIndex=logger.rowCnt%2)

    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      return None
    
  def swipeLeft (self,start_x_ratio="2/3", start_y_ratio="1/2", end_x_ratio="1/3", end_y_ratio="1/2", description="",printCmd=True,durationMs:int = 200):
    '''=================================================================
    + Name: swipeLeft (‚ö†Ô∏èüö® Action command -> Next command is WaitFor type)
    + Function: qu√©t m√†n h√¨nh t·ª´ ph·∫£i sang tr√°i t·ª´ v·ªã tr√≠ 2/3 m√†n h√¨nh ƒë·∫øn 1/3 m√†n h√¨nh. V·ªõi cao ƒë·ªô 1/2 chi·ªÅu cao m√†n h√¨nh.
    + Parameter:
      - description: Description will be printed out
      - durationMs: duration of swipe
    + Return: None.\n
    ================================================================='''
    #Print command and description
    commandName = "swipeLeft" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<APPIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
        
    try:
      self.driver.swipe(start_x=int(self.WIDTH*eval(start_x_ratio)),
                        start_y=int(self.HEIGHT*eval(start_y_ratio)),
                        end_x=int(self.WIDTH*eval(end_x_ratio)),
                        end_y=int(self.HEIGHT*eval(end_y_ratio)),
                        duration=durationMs)
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\ActionIcon.png",rowIndex=logger.rowCnt%2)
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()

  def swipeRight (self,start_x_ratio="1/3", start_y_ratio="1/2", end_x_ratio="2/3", end_y_ratio="1/2", description="",printCmd=True,durationMs:int = 200):
    '''=================================================================
    + Name: swipeRight (‚ö†Ô∏èüö® Action command -> Next command is WaitFor type)
    + Function: qu√©t m√†n h√¨nh t·ª´ tr√°i sang ph·∫£i t·ª´ v·ªã tr√≠ 1/3 m√†n h√¨nh ƒë·∫øn 2/3 m√†n h√¨nh. V·ªõi cao ƒë·ªô 1/2 chi·ªÅu cao m√†n h√¨nh.
    + Parameter:
      - description: Description will be printed out
      - durationMs: duration of swipe
    + Return: None.\n
    ================================================================='''
    #Print command and description
    commandName = "swipeRight" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<APPIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
        
    try:
      self.driver.swipe(start_x=int(self.WIDTH*eval(start_x_ratio)),
                        start_y=int(self.HEIGHT*eval(start_y_ratio)),
                        end_x=int(self.WIDTH*eval(end_x_ratio)),
                        end_y=int(self.HEIGHT*eval(end_y_ratio)),
                        duration=durationMs)
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\ActionIcon.png",rowIndex=logger.rowCnt%2)
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
    
  def flickUp (self,start_x_ratio="1/2", start_y_ratio="2/3", end_x_ratio="1/2", end_y_ratio="1/3", description="",printCmd=True,durationMs:int = 200):
    '''=================================================================
    + Name: flickUp (‚ö†Ô∏èüö® Action command -> Next command is WaitFor type)
    + Function: qu√©t m√†n h√¨nh t·ª´ d∆∞·ªõi l√™n tr√™n t·ª´ v·ªã tr√≠ 2/3 m√†n h√¨nh ƒë·∫øn 1/3 m√†n h√¨nh. V·ªõi chi·ªÅu ngang 1/2 m√†n h√¨nh.
    + Parameter:
      - description: Description will be printed out
      - durationMs: duration of swipe
    + Return: None.\n
    ================================================================='''
    #Print command and description
    commandName = "flickUp" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<APPIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
        
    try:
      self.driver.swipe(start_x=int(self.WIDTH*eval(start_x_ratio)),
                        start_y=int(self.HEIGHT*eval(start_y_ratio)),
                        end_x=int(self.WIDTH*eval(end_x_ratio)),
                        end_y=int(self.HEIGHT*eval(end_y_ratio)),
                        duration=durationMs)
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\ActionIcon.png",rowIndex=logger.rowCnt%2)
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
    
  def flickDown (self,start_x_ratio="1/2", start_y_ratio="1/3", end_x_ratio="1/2", end_y_ratio="2/3", description="",printCmd=True,durationMs:int = 200):
    '''=================================================================
    + Name: flickDown (‚ö†Ô∏èüö® Action command -> Next command is WaitFor type)
    + Function: qu√©t m√†n h√¨nh t·ª´ tr√™n xu·ªëng d∆∞·ªõi t·ª´ v·ªã tr√≠ 1/3 m√†n h√¨nh ƒë·∫øn 2/3 m√†n h√¨nh. V·ªõi chi·ªÅu ngang 1/2 m√†n h√¨nh.
    + Parameter:
      - description: Description will be printed out
      - durationMs: duration of swipe
    + Return: None.\n
    ================================================================='''
    #Print command and description
    commandName = "flickDown" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<APPIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
        
    try:
      self.driver.swipe(start_x=int(self.WIDTH*eval(start_x_ratio)),
                        start_y=int(self.HEIGHT*eval(start_y_ratio)),
                        end_x=int(self.WIDTH*eval(end_x_ratio)),
                        end_y=int(self.HEIGHT*eval(end_y_ratio)),
                        duration=durationMs)
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span>",mediaPath="Logs\RotateLogs\htmlAsset\ActionIcon.png",rowIndex=logger.rowCnt%2)
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
    
    
    
    
    
  ###########################
  ### 3.9 type            ###
  ###########################
  def type(self,target="",value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è type
    + Function: D√πng ƒë·ªÉ nh·∫≠p li·ªáu d·∫°ng string. Ch√∫ y: H√†m n√†y kh√¥ng hi·ªÉu c√°c ph√≠m ch·ª©c nƒÉng nh∆∞ SendKeys.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: Chu·ªói String c·∫ßn type
      - description: Description will be printed out
    + Return:
      - element n·∫øu c√≥ t·ªìn t·∫°i element ƒë·ªÉ type.
      - None: N·∫øu kh√¥ng t·ªìn t·∫°i element ƒë·ªÉ type.\n
    ================================================================='''
    #Print command and description
    commandName = "type" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    # if self.reqWaitCmdFlg == True:
    #   logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
    #   exit()
    
    #Function operation
    try:
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
      element.send_keys(value)
      self.reqWaitCmdFlg = True
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , Type="+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\ActionIcon.png",rowIndex=logger.rowCnt%2)
      return element
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      return None
      
  ###########################
  ### 3.10 sendKeys       ###
  ###########################
  def sendKeys(self,target="",class_Keys="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è sendKeys
    + Function: Gi·∫£ l·∫≠p vi·ªác nh·∫•n ph√≠m tr√™n b√†n ph√≠m. C√≥ th·ªÉ nh·∫≠p v√†o m·ªôt chu·ªói k√Ω t·ª± gi·ªëng nh∆∞ Type nh∆∞ng ƒë√¢y n√≥ c√≥ th·∫ª hi·ªÉu ƒë∆∞·ª£c c√°c ph√≠m ch·ª©c nƒÉng.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - class_Keys: Ph√≠m keys c·∫ßn g√µ d·∫°ng "${KEY_ENTER}","${KEY_DELETE}",...
      - description: Description will be printed out
    + Return:
      - element n·∫øu c√≥ t·ªìn t·∫°i element ƒë·ªÉ sendKey.
      - None: N·∫øu kh√¥ng t·ªìn t·∫°i element ƒë·ªÉ sendKey.\n
    ================================================================='''
    #Print command and description
    commandName = "sendKeys" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(class_Keys)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    # if self.reqWaitCmdFlg == True:
    #   logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
    #   exit()
    
    #Function operation
    try:
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
      value = self.__replaceSpecialKeys(class_Keys)
      element.send_keys(value)
      self.reqWaitCmdFlg = True
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , Keys="+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\ActionIcon.png",rowIndex=logger.rowCnt%2)
      return element
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      return None
  
  ###################################################################
  # 2. Wait For                                                     #
  ###################################################################
  ####################################
  ### 2.1 waitForElementPresent    ###
  ####################################
  def waitForElementPresent(self,target="",value=defaultWaitTimeMs,description="",printCmd=True):
    '''=================================================================
    + Name: üîÉ waitForElementPresent (‚ö†Ô∏è CH√ö √ù: Target ph·∫£i l√† duy nh·∫•t)
    + Function: The purpose of the wait for element present command is to wait for the element to be present on the UI and also the HTML DOM of the page.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: Th·ªùi gian timeout (ms) t·ªëi ƒëa cho vi·ªác wait. M·∫∑c ƒë·ªãnh l√† 30 gi√¢y.
      - description: Description will be printed out
    + Return:
      - [True,Element]: Tr·∫£ v·ªÅ list [True,Element] n·∫øu c√≥ s·ª± hi·ªán di·ªán c·ªßa n√≥ trong code (HTML DOM).
      - [False,None]  : N·∫øu kh√¥ng c√≥ s·ª± hi·ªán di·ªán c·ªßa n√≥ trong code (HTML DOM) v√† h·∫øt th·ªùi gian ƒë·ª£i.
    + Ref: https://www.qafox.com/new-selenium-ide-using-wait-for-element-present-command/ 
    + PIC: PIC/2.1.waitForElementPresent.png\n
    ================================================================='''
    value = self.defaultWaitTimeMs if value == "" else value
    #Print command and description
    commandName = "waitForElementPresent" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    self.reqWaitCmdFlg = False
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , TimeoutMs="+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\WaitIcon.png",rowIndex=logger.rowCnt%2)
      return [True,self.__waitForElementPresent(target,value)]
    except TimeoutException:
      if printCmd == True: logger.warning("WAITFOR TIMEOUT!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      return [False,None]
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WAIT FOR FAIL. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  ####################################
  ### 2.2 waitForElementNotPresent ###
  ####################################
  def waitForElementNotPresent(self,target="",value=defaultWaitTimeMs,description="",printCmd=True):
    '''=================================================================
    + Name: üîÉ waitForElementNotPresent (CH√ö √ù: Target ph·∫£i l√† duy nh·∫•t)
    + Function: The purpose of the wait for element not present command is to wait for the element to be not present on the UI and also its HTML code is not present in the HTML DOM of the page.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: Th·ªùi gian timeout (ms) t·ªëi ƒëa cho vi·ªác wait. M·∫∑c ƒë·ªãnh l√† 30 gi√¢y.
      - description: Description will be printed out
    + Return:
      - [True,None] : Tr·∫£ v·ªÅ list [True,None] n·∫øu code c·ªßa n√≥ bi·∫øn m·∫•t trong th·ªùi gian ƒë·ª£i (HTML DOM).
      - [False,None]: N·∫øu code c·ªßa n√≥ kh√¥ng bi·∫øn m·∫•t v√† h·∫øt th·ªùi gian ƒë·ª£i (HTML DOM) v√† h·∫øt th·ªùi gian ƒë·ª£i.
    + Ref: https://www.qafox.com/new-selenium-ide-using-wait-for-element-not-present-command/ \n
    ================================================================='''
    value = self.defaultWaitTimeMs if value == "" else value
    #Print command and description
    commandName = "waitForElementNotPresent" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    self.reqWaitCmdFlg = False
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      self.__waitForElementNotPresent(target,value)
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , TimeoutMs="+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\WaitIcon.png",rowIndex=logger.rowCnt%2)
      return [True,None]
    except TimeoutException:
      if printCmd == True: logger.warning("WAITFOR TIMEOUT!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      return [False,None]
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WAIT FOR FAIL. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  ####################################
  ### 2.3 waitForElementVisible    ###
  ####################################
  def waitForElementVisible(self,target="",value=defaultWaitTimeMs,description="",printCmd=True):
    '''=================================================================
    + Name: üîÉ waitForElementVisible (CH√ö √ù: Target ph·∫£i l√† duy nh·∫•t)
    + Function: ƒê·ª£i cho ƒë·∫øn khi element ƒë∆∞·ª£c hi·ªÉn th·ªã tr√™n UI.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: Th·ªùi gian timeout (ms) t·ªëi ƒëa cho vi·ªác wait. M·∫∑c ƒë·ªãnh l√† 30 gi√¢y.
      - description: Description will be printed out
    + Return:
      - [True,Element]: Tr·∫£ v·ªÅ list [True,Element] n·∫øu n√≥ xu·∫•t hi·ªán trong th·ªùi gian ƒë·ª£i.
      - [False,None]  : N·∫øu element kh√¥ng xu·∫•t hi·ªán v√† h·∫øt th·ªùi gian ƒë·ª£i.
    + Ref: https://www.qafox.com/new-selenium-ide-using-wait-for-element-visible-command/ 
    + PIC: PIC/2.3.waitForElementVisible.png\n
    ================================================================='''
    value = self.defaultWaitTimeMs if value == "" else value
    #Print command and description
    commandName = "waitForElementVisible" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    self.reqWaitCmdFlg = False
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , TimeoutMs="+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\WaitIcon.png",rowIndex=logger.rowCnt%2)
      return [True,self.__waitForElementVisible(target,value)]
    except TimeoutException:
      if printCmd == True: logger.warning("WAITFOR TIMEOUT!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      return [False,None]
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WAIT FOR FAIL. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  ####################################
  ### 2.4 waitForElementNotVisible ###
  ####################################
  def waitForElementNotVisible(self,target="",value=defaultWaitTimeMs,description="",printCmd=True):
    '''=================================================================
    + Name: üîÉ waitForElementNotVisible (CH√ö √ù: Target ph·∫£i l√† duy nh·∫•t)
    + Function: ƒê·ª£i cho ƒë·∫øn khi element ƒë∆∞·ª£c ·∫©n tr√™n UI.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: Th·ªùi gian timeout (ms) t·ªëi ƒëa cho vi·ªác wait. M·∫∑c ƒë·ªãnh l√† 30 gi√¢y.
      - description: Description will be printed out
    + Return:
      - [True,None] : Tr·∫£ v·ªÅ list [True,None] n·∫øu n√≥ bi·∫øn m·∫•t trong th·ªùi gian ƒë·ª£i.
      - [False,None]: N·∫øu element kh√¥ng bi·∫øn m·∫•t v√† h·∫øt th·ªùi gian ƒë·ª£i.
    + Ref: https://www.qafox.com/new-selenium-ide-using-wait-for-element-not-visible-command/ \n
    ================================================================='''
    value = self.defaultWaitTimeMs if value == "" else value
    #Print command and description
    commandName = "waitForElementNotVisible" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    self.reqWaitCmdFlg = False
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      self.__waitForElementNotVisible(target,value)
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , TimeoutMs="+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\WaitIcon.png",rowIndex=logger.rowCnt%2)
      return [True,None]
    except TimeoutException:
      if printCmd == True: logger.warning("WAITFOR TIMEOUT!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      return [False,None]
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WAIT FOR FAIL. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  ####################################
  ### 2.5 waitForElementEditable   ###
  ####################################
  def waitForElementEditable(self,target="",value=defaultWaitTimeMs,description="",printCmd=True):
    '''=================================================================
    + Name: üîÉ waitForElementEditable (CH√ö √ù: Target ph·∫£i l√† duy nh·∫•t)
    + Function: ƒê·ª£i cho ƒë·∫øn khi element ƒë∆∞·ª£c ch·ªânh s·ª≠a tr√™n UI.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: Th·ªùi gian timeout (ms) t·ªëi ƒëa cho vi·ªác wait. M·∫∑c ƒë·ªãnh l√† 30 gi√¢y.
      - description: Description will be printed out
    + Return:
      - [True,Element]: Tr·∫£ v·ªÅ list [True,Element] n·∫øu n√≥ ch·ªânh s·ª≠a ƒë∆∞·ª£c.
      - [False,None]  : N·∫øu element kh√¥ng ch·ªânh s·ª≠a ƒë∆∞·ª£c v√† h·∫øt th·ªùi gian ƒë·ª£i.
    + Ref: https://www.qafox.com/new-selenium-ide-using-wait-for-element-editable-command/ 
    + PIC: PIC/2.5.waitForElementEditable.png\n
    ================================================================='''
    value = self.defaultWaitTimeMs if value == "" else value
    #Print command and description
    commandName = "waitForElementEditable" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    self.reqWaitCmdFlg = False
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , TimeoutMs="+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\WaitIcon.png",rowIndex=logger.rowCnt%2)
      return [True,self.__waitForElementEditable(target,value)]
    except TimeoutException:
      if printCmd == True: logger.warning("WAITFOR TIMEOUT!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      return [False,None]
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WAIT FOR FAIL. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  #####################################
  ### 2.6 waitForElementNotEditable ###
  #####################################
  def waitForElementNotEditable(self,target="",value=defaultWaitTimeMs,description="",printCmd=True):
    '''=================================================================
    + Name: üîÉ waitForElementNotEditable (CH√ö √ù: Target ph·∫£i l√† duy nh·∫•t)
    + Function: ƒê·ª£i cho ƒë·∫øn khi element kh√¥ng ƒë∆∞·ª£c ph√©p ch·ªânh s·ª≠a tr√™n UI.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: Th·ªùi gian timeout (ms) t·ªëi ƒëa cho vi·ªác wait. M·∫∑c ƒë·ªãnh l√† 30 gi√¢y.
      - description: Description will be printed out
    + Return:
      - Element: Tr·∫£ v·ªÅ Element n·∫øu n√≥ kh√¥ng ƒë∆∞·ª£c ch·ªânh s·ª≠a.
      - None   : N·∫øu h·∫øt th·ªùi gian ƒë·ª£i.
    + Ref: https://www.qafox.com/new-selenium-ide-using-wait-for-element-not-editable-command/ \n
    ================================================================='''
    value = self.defaultWaitTimeMs if value == "" else value
    #Print command and description
    commandName = "waitForElementNotEditable" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    self.reqWaitCmdFlg = False
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , TimeoutMs="+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\WaitIcon.png",rowIndex=logger.rowCnt%2)
      return self.__waitForElementNotEditable(target,value)
    except TimeoutException:
      if printCmd == True: logger.warning("WAITFOR TIMEOUT!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      return None
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WAIT FOR FAIL. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  #####################################
  ### 2.7 waitForText               ###
  #####################################
  def waitForText(self,target="",value="" ,description="",printCmd=True):
    '''=================================================================
    + Name: üîÉ waitForText (CH√ö √ù: Target ph·∫£i l√† duy nh·∫•t)
    + Function: ƒê·ª£i n·ªôi dung text c·ªßa ƒë·ªëi t∆∞·ª£ng hi·ªán ra (CH√ö √ù: CHO PH√âP CONTAINS TEXT)
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: N·ªôi dung text c·ªßa ƒë·ªëi t∆∞·ª£ng mong ƒë·ª£i (CH√ö √ù: CHO PH√âP CONTAINS TEXT)
               Th·ªùi gian ƒë·ª£i m·∫∑c ƒë·ªãnh l√† defaultWaitTime (30 gi√¢y)
      - description: Description will be printed out
    + Return:
      - [True,None] : Tr·∫£ v·ªÅ list [True,None] n·∫øu n·ªôi dung text ƒë√≥ hi·ªán ra ·ªü ƒë·ªëi t∆∞·ª£ng element ƒë·∫ßu ti√™n kh·ªõp target.
      - [False,None]: N·ªôi dung text ƒë√≥ kh√¥ng hi·ªán ra trong th·ªùi gian ƒë·ªãnh.\n
    ================================================================='''
    #Print command and description
    commandName = "waitForText" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    self.reqWaitCmdFlg = False
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , TimeoutMs="+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\WaitIcon.png",rowIndex=logger.rowCnt%2)
      self.__waitForText(target,value)
      return [True,None]
    except TimeoutException:
      if printCmd == True: logger.warning("WAITFOR TIMEOUT!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      return [False,None]
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WAIT FOR FAIL. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  #####################################
  ### 2.8 waitForAttr               ###
  #####################################
  def waitForAttr(self,target="",value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è üîÉ waitForAttr (CH√ö √ù: Target ph·∫£i l√† duy nh·∫•t)
    + Function: ƒê·ª£i n·ªôi dung atribute c·ªßa ƒë·ªëi t∆∞·ª£ng hi·ªán kh·ªõp v·ªõi mong ƒë·ª£i (CH√ö √ù: CHO PH√âP CONTAINS TEXT)
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: ‚ö†Ô∏è D·∫°ng `<attributeName>=<attributeValue>`
      - description: Description will be printed out
    + Return:
      - [True,None] : Tr·∫£ v·ªÅ list [True,None] n·∫øu n·ªôi dung attribute kh·ªõp.
      - [False,None]: N·ªôi dung attribute kh√¥ng kh·ªõp trong th·ªùi gian ƒë·ªãnh.\n
    ================================================================='''
    #Print command and description
    commandName = "waitForAttr" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True:
      logger.allowLogging  = False #Skip logging from now on
      self.__printCmdDes(command,description)
      logger.allowLogging  = True # Allow logging from now on
    
    self.reqWaitCmdFlg = False
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      startTime = time.time()
      curTime = startTime
      attr = value.split("=")
      attrName = attr[0]  # ATTRIBUTE NAME
      attrValue = attr[1] # ATTRIBUTE VALUE
      while curTime - startTime <= float(self.defaultWaitTimeMs)/1000:
        curTime = time.time()
        
        # print("============================")
        # print(type(attrValue))
        # print(attrValue)
        # print(type(self.others_content_getAttribute(target,attrName)))
        # print(self.others_content_getAttribute(target,attrName))
        
        if element == None:
          if str(self.others_content_getAttribute(target,attrName)) == str(attrValue): return [True,None]
        else:
          if str(self.others_content_getAttribute(target,attrName,'','',element)) == str(attrValue): return [True,None]
      LotusLib.addMediaToHtmlLog(text="<span class='cmdStyle'>"+str(self.commandNum)+". "+commandName+"</span> ("+str(target)+" , TimeoutMs="+str(value)+")",mediaPath="Logs\RotateLogs\htmlAsset\WaitIcon.png",rowIndex=logger.rowCnt%2)
      return [False,None]
    except TimeoutException:
      if printCmd == True: logger.warning("WAITFOR TIMEOUT!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      return [False,None]
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WAIT FOR FAIL. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  
  ###################################################################
  # 9. LOGGING                                                      #
  ################################################################### 
  #######################################################
  ### 9.1 startRecordScreen             ###
  #######################################################
  def startRecordScreen (self):
    self.driver.start_recording_screen()
  
  def stopRecordScreen (self):
    self.driver.stop_recording_screen()
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  ###################################################################
  # 9. OTHERS                                                       #
  ################################################################### 
  #######################################################
  ### 9.1 others_content_findFirstElement             ###
  #######################################################
  def others_content_findFirstElement(self,target="",value="",description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è others_content_findFirstElement
    + Function: Tr·∫£ v·ªÅ element t√¨m th·∫•y ƒë·∫ßu ti√™n.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              (‚ö†Ô∏èüö® Ch√∫ √Ω: "//" s·∫Ω t√¨m ki·∫øm tr√™n to√†n b·ªô trang web. N·∫øu ch·ªâ t√¨m ki·∫øm trong element con th√¨ kh√¥ng c·∫ßn "//")
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: IDE.others.others_content_findLastElement("xpath=td",`element`=row)
      - value: None
      - description: Description will be printed out
    + Return:
      - True: First element.
      - False: Return None.\n
    ================================================================='''
    #Print command and description
    commandName = "others_content_findFirstElement" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<OTHER COMMAND:    {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      if element == None:
        element = self.findElement(target)
        element.location
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
      if element == None: return None
      return element
    except Exception:
      return None

  #####################################################
  ### 9.2 others_content_findLastElement            ###
  #####################################################
  def others_content_findLastElement(self,target="",value="",description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è others_content_findLastElement
    + Function: Tr·∫£ v·ªÅ element cu·ªëi c√πng t√¨m th·∫•y.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              (‚ö†Ô∏èüö® Ch√∫ √Ω: "//" s·∫Ω t√¨m ki·∫øm tr√™n to√†n b·ªô trang web. N·∫øu ch·ªâ t√¨m ki·∫øm trong element con th√¨ kh√¥ng c·∫ßn "//")
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: IDE.others.others_content_findLastElement("xpath=td",`element`=row)
      - value: None
      - description: Description will be printed out
    + Return:
      - True: Last element.
      - False: Return None.\n
    ================================================================='''
    #Print command and description
    commandName = "others_content_findLastElement" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<OTHER COMMAND:    {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      if element == None:
        elements = self.findElements(target)
      else:
        elements = self.others_browser_findChildElements(element,target,"",False)
      if (len(elements) == 0): return None
      return elements[len(elements)-1] #<--- RETURN LAST ELEMENT
    except Exception:
      return None

  #####################################################
  ### 9.2 others_content_findAllElements            ###
  #####################################################
  def others_content_findAllElements(self,target="",value="",description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è others_content_findAllElements
    + Function: Tr·∫£ v·ªÅ list c√°c element t√¨m th·∫•y.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              (‚ö†Ô∏èüö® Ch√∫ √Ω: "//" s·∫Ω t√¨m ki·∫øm tr√™n to√†n b·ªô trang web. N·∫øu ch·ªâ t√¨m ki·∫øm trong element con th√¨ kh√¥ng c·∫ßn "//")
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: IDE.others.others_content_findAllElements("xpath=td",`element`=row)
      - value: None
      - description: Description will be printed out
    + Return:
      - True: List of matched elements.
      - False: Return None.
    + EX: IDE.others.others_content_findAllElements("xpath=td",element=row)
      => Return all td elements in parent element: row\n
    ================================================================='''
    #Print command and description
    commandName = "others_content_findAllElements" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<OTHER COMMAND:    {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      if element == None:
        elements = self.findElements(target)
      else:
        elements = self.others_browser_findChildElements(element,target,"",False)
      if (len(elements) == 0): return None
      return elements
    except Exception:
      return None
  
  #####################################################
  ### 9.4 others_content_getPageSourceCode          ###
  #####################################################
  def others_content_getPageSourceCode(self,target="",value="",description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è others_content_getPageSourceCode
    + Function: Tr·∫£ v·ªÅ source code c·ªßa page hi·ªán t·∫°i.
    + Parameter:
      - target: None
      - value: None
      - description: Description will be printed out
    + Return: Source code c·ªßa page hi·ªán t·∫°i\n
    ================================================================='''
    #Print command and description
    commandName = "others_content_getPageSourceCode" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<OTHER COMMAND:    {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      if element == None:
        return self.driver.page_source
      else:
        return element.get_attribute('innerHTML')

    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("CANNOT GET PAGE SOURCE CODE. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      
  #############################################
  ###  9.20 others_keyMouse_rightClick      ###
  #############################################
  def others_keyMouse_rightClick(self,target="",value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è others_keyMouse_rightClick (‚ö†Ô∏èüö® Action command -> Next command is WaitFor type)
    + Function: The purpose of rightClick command in Selenium IDE, is to rightClick on any UI element in the application.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: None
      - description: Description will be printed out
    + Return: None\n
    ================================================================='''
    #Print command and description
    commandName = "others_keyMouse_rightClick" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
      actions = ActionChains(self.driver)
      actions.context_click(element).perform()
      self.reqWaitCmdFlg = True
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("CANNOT RIGHT CLICK. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  #############################################
  ###  9.21 others_keyMouse_hotkeys         ###
  #############################################
  def others_keyMouse_hotkeys(self,target="",value="" ,description="",printCmd=True):
    '''=================================================================
    + Name: others_keyMouse_hotkeys (‚ö†Ô∏èüö® Action command -> Next command is WaitFor type)
    + Function: G·ª≠i t·ªï h·ª£p ph√≠m n√≥ng.
    + Parameter:
      - target: T·ªï h·ª£p ph√≠m n√≥ng (Ch·ªâ cho ph√©p l√† t·ªï h·ª£p v·ªõi c√°c ph√≠m ctrl, shilf, alt, command, meta). Ex: "ctrl+c", "ctrl+alt+del".
      - value: None
      - description: Description will be printed out
    + Return: None
    + Example:
      - others_keyMouse_hotkeys("ctrl+c")
      - others_keyMouse_hotkeys("ctrl+alt+del")\n
    ================================================================='''
    #Print command and description
    commandName = "others_keyMouse_hotkeys" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      hotKeys = target.split('+')    
      actions = ActionChains(self.driver)
      
      #Action key down
      for key in hotKeys:
        if key=="ctrl"   : 
          actions.key_down(Keys.CONTROL)
          continue
        if key=="shilf"  : 
          actions.key_down(Keys.SHIFT)  
          continue
        if key=="alt"    : 
          actions.key_down(Keys.ALT)    
          continue
        if key=="command": 
          actions.key_down(Keys.COMMAND)
          continue
        if key=="meta"   : 
          actions.key_down(Keys.META)   
          continue
        actions.send_keys(key)
        
      #Action key up
      for key in hotKeys:
        if key=="ctrl"   : 
          actions.key_up(Keys.CONTROL)
          continue
        if key=="shilf"  : 
          actions.key_up(Keys.SHIFT)  
          continue
        if key=="alt"    : 
          actions.key_up(Keys.ALT)    
          continue
        if key=="command": 
          actions.key_up(Keys.COMMAND)
          continue
        if key=="meta"   : 
          actions.key_up(Keys.META)   
          continue

      actions.perform()
      self.reqWaitCmdFlg = True
      
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("CANNOT RIGHT CLICK. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  ###############################################
  ###  9.22 others_content_getNumberOfIframes ###
  ###############################################
  def others_content_getNumberOfIframes(self,target="None",value="None" ,description="",printCmd=True):
    '''=================================================================
    + Name: others_content_getNumberofIframes
    + Function: Count current iframe in html code.
    + Parameter:
      - target: None
      - value: None
      - description: Description will be printed out
    + Return: S·ªë l∆∞·ª£ng iframe\n
    ================================================================='''
    #Print command and description
    commandName = "others_content_getNumberOfIframes" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      iframe = self.driver.find_elements(By.TAG_NAME, "iframe")
      return len(iframe)
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("CANNOT GET NUMBER OF IFRAME. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  ###############################################
  ###  9.23 others_content_waitNewIframeOpen  ###
  ###############################################
  def others_content_waitNewIframeOpen(self,target=0 ,value=30000 ,description="",printCmd=True):
    '''=================================================================
    + Name: üîÉ others_content_waitNewIframeOpen
    + Function: Ch·ªù m·ªôt iframe m·ªõi ƒë∆∞·ª£c m·ªü ra (VD: popup login Google)
    + Parameter:
      - target: S·ªë l∆∞·ª£ng iframe tr∆∞·ªõc khi ƒë·ª£i s·ª± ki·ªán (ch·∫°y b·ªüi self.others_content_getNumberOfIframes) 
      - value: Nh·∫≠p v√†o gi√° tr·ªã th·ªùi gian ƒë∆°n v·ªã ms.
      - description: Description will be printed out
    + Return: Tuple. (True/False,S·ªë l∆∞·ª£ng iframe m·ªõi). True khi c√≥ iframe m·ªõi v√† False khi timeout.\n
    ================================================================='''
    value = 30000 if value == "" else value
    #Print command and description
    commandName = "others_content_waitNewIframeOpen" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    self.reqWaitCmdFlg = False
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      startIframeNum = int(target)
      timeoutSec = int(value)/1000
      end_time = time.time() + timeoutSec
      while True:
        endIframeNum = len(self.driver.find_elements(By.TAG_NAME,"iframe"))
        if endIframeNum > startIframeNum:
          return True,endIframeNum
        
        time.sleep(0.1)
        if time.time() > end_time:
          logger.error("TIMEOUT. CANNOT FIND NEW IFRAME!!!")
          LotusLib.addScreenCaptureToHtmlLog()
          return False,endIframeNum

    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("CANNOT FIND NEW IFRAME. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  def others_content_getAttribute(self,target="" ,value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è others_content_getAttribute
    + Function: L·∫•y gi√° tri t·ª´ thu·ªôc t√≠nh c·ªßa th·∫ª.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: t√™n attribution. Ex: id, type, src,...
      - description: Description will be printed out
    + Return: Gi√° tr·ªã c·ªßa attribution - Return None n·∫øu ƒë·ªëi t∆∞·ª£ng kh√¥ng t√¨m th·∫•y.\n
    ================================================================='''
    #Print command and description
    commandName = "others_content_getAttribute" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
      if element == None: return None
      elementAttrValue = element.get_attribute(value)
      return elementAttrValue
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("ASSERT FAIL. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
    
  def others_content_getText(self,target="" ,value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è others_content_getText
    + Function: L·∫•y text() t·ª´ ƒë·ªëi t∆∞·ª£ng.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: None
      - description: Description will be printed out
    + Return: Gi√° tr·ªã c·ªßa attribution - Return None n·∫øu ƒë·ªëi t∆∞·ª£ng kh√¥ng t√¨m th·∫•y.\n
    ================================================================='''
    #Print command and description
    commandName = "others_content_getText" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
      print("DEBUG <<<<<<")
      print(element)
      if element == None: return None
      elementText = element.text
      return elementText
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("ASSERT FAIL. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
    
  
  ###############################################
  ###  9.24 others_debug_printTabIframeInfo   ###
  ###############################################
  def others_debug_printTabIframeInfo(self,target="" ,value="" ,description="",printCmd=True):
    '''=================================================================
    + Name: others_debug_printTabIframeInfo
    + Function: In th√¥ng tin v·ªÅ tab v√† s·ªë iframe ra m√†n h√¨nh.
    + Parameter:
      - target: None
      - value: None
      - description: Description will be printed out
    + Return: None\n
    ================================================================='''
    #Print command and description
    commandName = "others_debug_printTabIframeInfo" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      main_handler = self.driver.current_window_handle
      print('-'*100)
      print('{n:<10}{i:<11}{h:<45}{t:<}'.format(dashes = '-'*100, n = 'TabIndex', i = 'IframeNum', h = 'Window handler',t = 'Tab Title'))
      print('-'*100)
      
      checkingTab = 0
      for handle in self.driver.window_handles:
        self.driver.switch_to.window(handle)
        iframeNum = len(self.driver.find_elements(By.TAG_NAME,"iframe"))
        if (handle == main_handler):
          if iframeNum == 0:
            iFrameNumStr = "0"
          else:
            iFrameNumStr = str(iframeNum) + " (Id:" + str(iframeNum - 1) + ")"
            
          print('{n:<10}{i:<11}{h:<45}{t:<}'.format(n = "=> "+str(checkingTab), i = iFrameNumStr, h=handle, t = self.driver.title))
        else:
          iFrameNumStr = "0"
          print('   {n:<7}{i:<11}{h:<45}{t:<}'.format(n = str(checkingTab), i = iFrameNumStr, h=handle, t = self.driver.title))
        checkingTab+=1
      self.driver.switch_to.window(main_handler)
      print('-'*100+'\n')

    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("CANNOT PRINT DEBUG TAB/IFRAME TABLE. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  #######################################################
  ### 9.29 others_debug_printComment                  ###
  #######################################################
  def others_debug_printComment(self,target="",value="",description="",printCmd=True):
    '''=================================================================
    + Name: others_debug_printComment
    + Function: In comment v√† xu·ªëng d√≤ng.
    + Parameter:
      - target: Comment 1
      - value: Comment 2
      - description: Description will be printed out
    + Return: None\n
    ================================================================='''
    #Print command and description
    if printCmd == True:  self.commandNum += 1
    command = "<OTHER COMMAND:    {commandNum}> ".format(commandNum=self.commandNum)+target+value
    if printCmd == True: self.__printCmdDes(command,description)
    
  #######################################################
  ### 9.30 clearReqWaitCmdFlg                         ###
  #######################################################
  def clearReqWaitCmdFlg(self):
    '''=================================================================
    + Name: üîÉ clearReqWaitCmdFlg
    + Function: X√≥a c·ªù self.reqWaitCmdFlg
    + Parameter: None
    + Return: None\n
    ================================================================='''
    self.reqWaitCmdFlg = False
  
  #######################################################
  ### 9.31 clearExitOnExceptionFlg                    ###
  #######################################################
  def clearExitOnExceptionFlg(self):
    '''=================================================================
    + Name: üîÉ clearExitOnExceptionFlg
    + Function: X√≥a c·ªù self.exitOnExceptionFlg -> Ch·∫°y ti·∫øp n·∫øu g·∫∑p exception.
    + Parameter: None
    + Return: None\n
    ================================================================='''
    self.exitOnExceptionFlg = False
  
  #######################################################
  ### 9.32 setExitOnExceptionFlg                      ###
  #######################################################
  def setExitOnExceptionFlg(self):
    '''=================================================================
    + Name: üîÉ setExitOnExceptionFlg
    + Function: Set c·ªù self.exitOnExceptionFlg -> Exit n·∫øu g·∫∑p exception.
    + Parameter: None
    + Return: None\n
    ================================================================='''
    self.exitOnExceptionFlg = True
  
  def others_content_getPosSizeElement (self,target="",value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è others_content_getPosSizeElement
    + Function: Tr·∫£ v·ªÅ v·ªã tr√≠ b·∫Øt ƒë·∫ßu v√† k√≠ch th∆∞·ªõc WxH c·ªßa element.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: None
      - description: Description will be printed out
    + Return: D·∫°ng dict c√≥ c√°c ph·∫ßn t·ª≠ d·∫°ng int ch·ª©a {x,y,width,height}. V·ªã tr√≠ v√† k√≠ch th∆∞·ªõc c·ªßa element.
    + Example: others_content_getPosSizeElement("id=slider_001")\n
    ‚ú® => {'x': 396, 'y': 21, 'width': 161, 'height': 19}\n
    ================================================================='''
    #Print command and description
    commandName = "others_content_getPosSizeElement" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      # print(target)
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
      posObj = element.rect #<--- Get element position and size
      return dict(x=int(posObj['x']),y=int(posObj['y']),width=int(posObj['width']),height=int(posObj['height']))
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()

  def others_content_getPosMidElement (self,target="",value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è others_content_getPosMidElement
    + Function: Tr·∫£ v·ªÅ v·ªã tr√≠ trung t√¢m c·ªßa element.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: None
      - description: Description will be printed out
    + Return: V·ªã tr√≠ trung t√¢m [int(x),int(y)] c·ªßa element.\n
    + Example: others_content_getPosMidElement("id=slider_001")\n
    ‚ú® => [396, 21]\n
    ================================================================='''
    #Print command and description
    commandName = "others_content_getPosMidElement" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      # print(target)
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
      posObj = element.rect #<--- Get element position and size
      return int(posObj["x"]+posObj["width"]/2),int(posObj["y"]+posObj["height"]/2) #<--- Get element position and size
    
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()

  def others_content_saveElementScreenshot (self,target="",value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è others_content_saveElementScreenshot
    + Function: Ch·ª•p ·∫£nh Element v√† l∆∞u l·∫°i
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: ƒê∆∞·ªùng d·∫´n v√† t√™n file s·∫Ω l∆∞u
      - description: Description will be printed out
    + Return: ƒê∆∞·ªùng d·∫´n ƒë·∫øn file ƒë∆∞·ª£c l∆∞u.\n
    + Example: others_content_saveElementScreenshot("id=slider_001","/home/sliderPicture.png")\n
    ================================================================='''
    #Print command and description
    commandName = "others_content_saveElementScreenshot" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      # print(target)
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
      element.screenshot(value) #<--- Get element position and size
      return value
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("WRONG TARGET. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  ############################################################################################
  ############################################################################################
  ############################################################################################
  def refreshBrowserTabNumOnly (self):
    self.browserTabNum = len(self.driver.window_handles)
    return self.browserTabNum

  def refreshBrowserTabInfo (self,backCurrentTab=True):
    self.browserTabList = []   #Clear Tab list
    self.browserTabHandle = [] #Clear Tab handle
    self.browserTabNum = 0     #Clear Tab Number
    main_handler = ""
    if backCurrentTab == True: main_handler = self.driver.current_window_handle

    for handle in self.driver.window_handles:
      self.driver.switch_to.window(handle)
      self.browserTabList.append(self.driver.title)
      self.browserTabHandle.append(handle)
    self.browserTabNum = len(self.browserTabList)
    if backCurrentTab == True: self.driver.switch_to.window(main_handler)

  def others_content_getAttribute(self,target="" ,value="" ,description="",printCmd=True, element:WebElement = None):
    '''=================================================================
    + Name: ‚ò∏Ô∏è others_content_getAttribute
    + Function: L·∫•y gi√° tri t·ª´ thu·ªôc t√≠nh c·ªßa th·∫ª.
    + Parameter:
      - target: Tr·ªè ƒë·∫øn element. C√≥ 8 ki·ªÉu x√°c ƒë·ªãnh: xpath, tag, class, id, name, css, link text, partial link text.
              - EX1: xpath=//a[contains(@data-e2e,'tiktok-logo')]
              - EX2: tag=a, class=btn, id=btn, name=btn, css=btn, link text=btn,
      - value: t√™n attribution. Ex: id, type, src,...
      - description: Description will be printed out
    + Return: Gi√° tr·ªã c·ªßa attribution - Return None n·∫øu ƒë·ªëi t∆∞·ª£ng kh√¥ng t√¨m th·∫•y.\n
    ================================================================='''
    #Print command and description
    commandName = "others_content_getAttribute" #<--- FUNCTION NAME
    if printCmd == True:  self.commandNum += 1
    command = "<SELENIUM COMMAND: {commandNum}> ".format(commandNum=self.commandNum)+commandName+"("+str(target)+" , "+str(value)+")"
    if printCmd == True: self.__printCmdDes(command,description)
    
    if self.reqWaitCmdFlg == True:
      logger.fatal(">>>>> COMMAND WAIT IS REQUESTED. BUT THIS COMMAND IS NOT!!!")
      exit()
    
    #Function operation
    try:
      if element == None:
        element = self.findElement(target)
      else:
        element = self.others_browser_findChildElement(element,target,"",False)
      if element == None: return None
      elementAttrValue = element.get_attribute(value)
      return elementAttrValue
    except Exception as e:
      logger.fatal("%s",e)
      logger.fatal("ASSERT FAIL. PROGRAM STOPPED!!!")
      LotusLib.addScreenCaptureToHtmlLog()
      if self.exitOnExceptionFlg == True: exit()
      
  def __replaceSpecialKeys(self,value=""):
    # print("BEFORE" + value)
    value = value.replace("${KEY_NULL}"                ,u'\ue000')
    value = value.replace("${KEY_CANCEL}"              ,u'\ue001') #BREAK
    value = value.replace("${KEY_HELP}"                ,u'\ue002')
    value = value.replace("${KEY_BACKSPACE}"           ,u'\ue003')
    value = value.replace("${KEY_BACK_SPACE}"          ,u'\ue003')
    value = value.replace("${KEY_TAB}"                 ,u'\ue004')
    value = value.replace("${KEY_CLEAR}"               ,u'\ue005')
    value = value.replace("${KEY_RETURN}"              ,u'\ue006')
    value = value.replace("${KEY_ENTER}"               ,u'\ue007')
    value = value.replace("${KEY_SHIFT}"               ,u'\ue008')
    value = value.replace("${KEY_LEFT_SHIFT}"          ,u'\ue008')
    value = value.replace("${KEY_CONTROL}"             ,u'\ue009')
    value = value.replace("${KEY_LEFT_CONTROL}"        ,u'\ue009')
    value = value.replace("${KEY_ALT}"                 ,u'\ue00a')
    value = value.replace("${KEY_LEFT_ALT}"            ,u'\ue00a')
    value = value.replace("${KEY_PAUSE}"               ,u'\ue00b')
    value = value.replace("${KEY_ESCAPE}"              ,u'\ue00c')
    value = value.replace("${KEY_SPACE}"               ,u'\ue00d')
    value = value.replace("${KEY_PAGE_UP}"             ,u'\ue00e')
    value = value.replace("${KEY_PAGE_DOWN}"           ,u'\ue00f')
    value = value.replace("${KEY_END}"                 ,u'\ue010')
    value = value.replace("${KEY_HOME}"                ,u'\ue011')
    value = value.replace("${KEY_LEFT}"                ,u'\ue012')
    value = value.replace("${KEY_ARROW_LEFT}"          ,u'\ue012')
    value = value.replace("${KEY_UP}"                  ,u'\ue013')
    value = value.replace("${KEY_ARROW_UP}"            ,u'\ue013')
    value = value.replace("${KEY_RIGHT}"               ,u'\ue014')
    value = value.replace("${KEY_ARROW_RIGHT}"         ,u'\ue014')
    value = value.replace("${KEY_DOWN}"                ,u'\ue015')
    value = value.replace("${KEY_ARROW_DOWN}"          ,u'\ue015')
    value = value.replace("${KEY_INSERT}"              ,u'\ue016')
    value = value.replace("${KEY_DELETE}"              ,u'\ue017')
    value = value.replace("${KEY_SEMICOLON}"           ,u'\ue018')
    value = value.replace("${KEY_EQUALS}"              ,u'\ue019')
    value = value.replace("${KEY_NUMPAD0}"             ,u'\ue01a') # Keypad  keys
    value = value.replace("${KEY_NUMPAD1}"             ,u'\ue01b')
    value = value.replace("${KEY_NUMPAD2}"             ,u'\ue01c')
    value = value.replace("${KEY_NUMPAD3}"             ,u'\ue01d')
    value = value.replace("${KEY_NUMPAD4}"             ,u'\ue01e')
    value = value.replace("${KEY_NUMPAD5}"             ,u'\ue01f')
    value = value.replace("${KEY_NUMPAD6}"             ,u'\ue020')
    value = value.replace("${KEY_NUMPAD7}"             ,u'\ue021')
    value = value.replace("${KEY_NUMPAD8}"             ,u'\ue022')
    value = value.replace("${KEY_NUMPAD9}"             ,u'\ue023')
    value = value.replace("${KEY_MULTIPLY}"            ,u'\ue024')
    value = value.replace("${KEY_ADD}"                 ,u'\ue025')
    value = value.replace("${KEY_SEPARATOR}"           ,u'\ue026')
    value = value.replace("${KEY_SUBTRACT}"            ,u'\ue027')
    value = value.replace("${KEY_DECIMAL}"             ,u'\ue028')
    value = value.replace("${KEY_DIVIDE}"              ,u'\ue029')
    value = value.replace("${KEY_F1}"                  ,u'\ue031') # function  keys
    value = value.replace("${KEY_F2}"                  ,u'\ue032')
    value = value.replace("${KEY_F3}"                  ,u'\ue033')
    value = value.replace("${KEY_F4}"                  ,u'\ue034')
    value = value.replace("${KEY_F5}"                  ,u'\ue035')
    value = value.replace("${KEY_F6}"                  ,u'\ue036')
    value = value.replace("${KEY_F7}"                  ,u'\ue037')
    value = value.replace("${KEY_F8}"                  ,u'\ue038')
    value = value.replace("${KEY_F9}"                  ,u'\ue039')
    value = value.replace("${KEY_F10}"                 ,u'\ue03a')
    value = value.replace("${KEY_F11}"                 ,u'\ue03b')
    value = value.replace("${KEY_F12}"                 ,u'\ue03c')
    value = value.replace("${KEY_META}"                ,u'\ue03d')
    value = value.replace("${KEY_COMMAND}"             ,u'\ue03d')
    # print("AFTER" + value)
    return value
  
  def __waitForElementPresent(self,target="",value=""):
    if target.startswith("xpath="):         return WebDriverWait(self.driver,float(value)/1000).until(EC.presence_of_element_located((By.XPATH            ,target[len("xpath=")      :])))
    if target.startswith("tag="):           return WebDriverWait(self.driver,float(value)/1000).until(EC.presence_of_element_located((By.TAG_NAME         ,target[len("tag=")        :])))
    if target.startswith("class="):         return WebDriverWait(self.driver,float(value)/1000).until(EC.presence_of_element_located((By.CLASS_NAME       ,target[len("class=")      :])))
    if target.startswith("id="):            return WebDriverWait(self.driver,float(value)/1000).until(EC.presence_of_element_located((By.ID               ,target[len("id=")         :])))
    if target.startswith("name="):          return WebDriverWait(self.driver,float(value)/1000).until(EC.presence_of_element_located((By.NAME             ,target[len("name=")       :])))
    if target.startswith("css="):           return WebDriverWait(self.driver,float(value)/1000).until(EC.presence_of_element_located((By.CSS_SELECTOR     ,target[len("css=")        :])))
    if target.startswith("link="):          return WebDriverWait(self.driver,float(value)/1000).until(EC.presence_of_element_located((By.LINK_TEXT        ,target[len("link=")       :])))
    if target.startswith("partLink="):      return WebDriverWait(self.driver,float(value)/1000).until(EC.presence_of_element_located((By.PARTIAL_LINK_TEXT,target[len("partLink=")   :])))
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'
  
  def __waitForElementNotPresent(self,target="",value=""):
    if target.startswith("xpath="):         return WebDriverWait(self.driver,float(value)/1000).until_not(EC.presence_of_element_located((By.XPATH            ,target[len("xpath=")      :])))
    if target.startswith("tag="):           return WebDriverWait(self.driver,float(value)/1000).until_not(EC.presence_of_element_located((By.TAG_NAME         ,target[len("tag=")        :])))
    if target.startswith("class="):         return WebDriverWait(self.driver,float(value)/1000).until_not(EC.presence_of_element_located((By.CLASS_NAME       ,target[len("class=")      :])))
    if target.startswith("id="):            return WebDriverWait(self.driver,float(value)/1000).until_not(EC.presence_of_element_located((By.ID               ,target[len("id=")         :])))
    if target.startswith("name="):          return WebDriverWait(self.driver,float(value)/1000).until_not(EC.presence_of_element_located((By.NAME             ,target[len("name=")       :])))
    if target.startswith("css="):           return WebDriverWait(self.driver,float(value)/1000).until_not(EC.presence_of_element_located((By.CSS_SELECTOR     ,target[len("css=")        :])))
    if target.startswith("link="):          return WebDriverWait(self.driver,float(value)/1000).until_not(EC.presence_of_element_located((By.LINK_TEXT        ,target[len("link=")       :])))
    if target.startswith("partLink="):      return WebDriverWait(self.driver,float(value)/1000).until_not(EC.presence_of_element_located((By.PARTIAL_LINK_TEXT,target[len("partLink=")   :])))
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'
  
  def __waitForElementVisible(self,target="",value=""):
    if target.startswith("xpath="):         return WebDriverWait(self.driver,float(value)/1000).until(EC.visibility_of_element_located((By.XPATH            ,target[len("xpath=")      :])))
    if target.startswith("tag="):           return WebDriverWait(self.driver,float(value)/1000).until(EC.visibility_of_element_located((By.TAG_NAME         ,target[len("tag=")        :])))
    if target.startswith("class="):         return WebDriverWait(self.driver,float(value)/1000).until(EC.visibility_of_element_located((By.CLASS_NAME       ,target[len("class=")      :])))
    if target.startswith("id="):            return WebDriverWait(self.driver,float(value)/1000).until(EC.visibility_of_element_located((By.ID               ,target[len("id=")         :])))
    if target.startswith("name="):          return WebDriverWait(self.driver,float(value)/1000).until(EC.visibility_of_element_located((By.NAME             ,target[len("name=")       :])))
    if target.startswith("css="):           return WebDriverWait(self.driver,float(value)/1000).until(EC.visibility_of_element_located((By.CSS_SELECTOR     ,target[len("css=")        :])))
    if target.startswith("link="):          return WebDriverWait(self.driver,float(value)/1000).until(EC.visibility_of_element_located((By.LINK_TEXT        ,target[len("link=")       :])))
    if target.startswith("partLink="):      return WebDriverWait(self.driver,float(value)/1000).until(EC.visibility_of_element_located((By.PARTIAL_LINK_TEXT,target[len("partLink=")   :])))
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'
  
  def __waitForElementNotVisible(self,target="",value=""):
    if target.startswith("xpath="):         return WebDriverWait(self.driver,float(value)/1000).until_not(EC.visibility_of_element_located((By.XPATH            ,target[len("xpath=")      :])))
    if target.startswith("tag="):           return WebDriverWait(self.driver,float(value)/1000).until_not(EC.visibility_of_element_located((By.TAG_NAME         ,target[len("tag=")        :])))
    if target.startswith("class="):         return WebDriverWait(self.driver,float(value)/1000).until_not(EC.visibility_of_element_located((By.CLASS_NAME       ,target[len("class=")      :])))
    if target.startswith("id="):            return WebDriverWait(self.driver,float(value)/1000).until_not(EC.visibility_of_element_located((By.ID               ,target[len("id=")         :])))
    if target.startswith("name="):          return WebDriverWait(self.driver,float(value)/1000).until_not(EC.visibility_of_element_located((By.NAME             ,target[len("name=")       :])))
    if target.startswith("css="):           return WebDriverWait(self.driver,float(value)/1000).until_not(EC.visibility_of_element_located((By.CSS_SELECTOR     ,target[len("css=")        :])))
    if target.startswith("link="):          return WebDriverWait(self.driver,float(value)/1000).until_not(EC.visibility_of_element_located((By.LINK_TEXT        ,target[len("link=")       :])))
    if target.startswith("partLink="):      return WebDriverWait(self.driver,float(value)/1000).until_not(EC.visibility_of_element_located((By.PARTIAL_LINK_TEXT,target[len("partLink=")   :])))
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'
  
  def __waitForElementEditable(self,target="",value=""):
    if target.startswith("xpath="):         return WebDriverWait(self.driver,float(value)/1000).until(EC.element_to_be_clickable((By.XPATH            ,target[len("xpath=")      :])))
    if target.startswith("tag="):           return WebDriverWait(self.driver,float(value)/1000).until(EC.element_to_be_clickable((By.TAG_NAME         ,target[len("tag=")        :])))
    if target.startswith("class="):         return WebDriverWait(self.driver,float(value)/1000).until(EC.element_to_be_clickable((By.CLASS_NAME       ,target[len("class=")      :])))
    if target.startswith("id="):            return WebDriverWait(self.driver,float(value)/1000).until(EC.element_to_be_clickable((By.ID               ,target[len("id=")         :])))
    if target.startswith("name="):          return WebDriverWait(self.driver,float(value)/1000).until(EC.element_to_be_clickable((By.NAME             ,target[len("name=")       :])))
    if target.startswith("css="):           return WebDriverWait(self.driver,float(value)/1000).until(EC.element_to_be_clickable((By.CSS_SELECTOR     ,target[len("css=")        :])))
    if target.startswith("link="):          return WebDriverWait(self.driver,float(value)/1000).until(EC.element_to_be_clickable((By.LINK_TEXT        ,target[len("link=")       :])))
    if target.startswith("partLink="):      return WebDriverWait(self.driver,float(value)/1000).until(EC.element_to_be_clickable((By.PARTIAL_LINK_TEXT,target[len("partLink=")   :])))
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'
  
  def __waitForElementNotEditable(self,target="",value=""):
    if target.startswith("xpath="):         return WebDriverWait(self.driver,float(value)/1000).until_not(EC.element_to_be_clickable((By.XPATH            ,target[len("xpath=")      :])))
    if target.startswith("tag="):           return WebDriverWait(self.driver,float(value)/1000).until_not(EC.element_to_be_clickable((By.TAG_NAME         ,target[len("tag=")        :])))
    if target.startswith("class="):         return WebDriverWait(self.driver,float(value)/1000).until_not(EC.element_to_be_clickable((By.CLASS_NAME       ,target[len("class=")      :])))
    if target.startswith("id="):            return WebDriverWait(self.driver,float(value)/1000).until_not(EC.element_to_be_clickable((By.ID               ,target[len("id=")         :])))
    if target.startswith("name="):          return WebDriverWait(self.driver,float(value)/1000).until_not(EC.element_to_be_clickable((By.NAME             ,target[len("name=")       :])))
    if target.startswith("css="):           return WebDriverWait(self.driver,float(value)/1000).until_not(EC.element_to_be_clickable((By.CSS_SELECTOR     ,target[len("css=")        :])))
    if target.startswith("link="):          return WebDriverWait(self.driver,float(value)/1000).until_not(EC.element_to_be_clickable((By.LINK_TEXT        ,target[len("link=")       :])))
    if target.startswith("partLink="):      return WebDriverWait(self.driver,float(value)/1000).until_not(EC.element_to_be_clickable((By.PARTIAL_LINK_TEXT,target[len("partLink=")   :])))
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'

  def __waitForText(self,target="",value=""):
    if target.startswith("xpath="):         return WebDriverWait(self.driver,float(self.defaultWaitTimeMs)/1000).until(EC.text_to_be_present_in_element((By.XPATH            ,target[len("xpath=")      :]),value))
    if target.startswith("tag="):           return WebDriverWait(self.driver,float(self.defaultWaitTimeMs)/1000).until(EC.text_to_be_present_in_element((By.TAG_NAME         ,target[len("tag=")        :]),value))
    if target.startswith("class="):         return WebDriverWait(self.driver,float(self.defaultWaitTimeMs)/1000).until(EC.text_to_be_present_in_element((By.CLASS_NAME       ,target[len("class=")      :]),value))
    if target.startswith("id="):            return WebDriverWait(self.driver,float(self.defaultWaitTimeMs)/1000).until(EC.text_to_be_present_in_element((By.ID               ,target[len("id=")         :]),value))
    if target.startswith("name="):          return WebDriverWait(self.driver,float(self.defaultWaitTimeMs)/1000).until(EC.text_to_be_present_in_element((By.NAME             ,target[len("name=")       :]),value))
    if target.startswith("css="):           return WebDriverWait(self.driver,float(self.defaultWaitTimeMs)/1000).until(EC.text_to_be_present_in_element((By.CSS_SELECTOR     ,target[len("css=")        :]),value))
    if target.startswith("link="):          return WebDriverWait(self.driver,float(self.defaultWaitTimeMs)/1000).until(EC.text_to_be_present_in_element((By.LINK_TEXT        ,target[len("link=")       :]),value))
    if target.startswith("partLink="):      return WebDriverWait(self.driver,float(self.defaultWaitTimeMs)/1000).until(EC.text_to_be_present_in_element((By.PARTIAL_LINK_TEXT,target[len("partLink=")   :]),value))
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'
  
  def findElement (self,target=""):
    if target.startswith("xpath="):    return self.driver.find_element(By.XPATH            ,target[len("xpath="):]   )
    if target.startswith("tag="):      return self.driver.find_element(By.TAG_NAME         ,target[len("tag="):]     )
    if target.startswith("class="):    return self.driver.find_element(By.CLASS_NAME       ,target[len("class="):]   )
    if target.startswith("id="):       return self.driver.find_element(By.ID               ,target[len("id="):]      )
    if target.startswith("name="):     return self.driver.find_element(By.NAME             ,target[len("name="):]    )
    if target.startswith("css="):      return self.driver.find_element(By.CSS_SELECTOR     ,target[len("css="):]     )
    if target.startswith("link="):     return self.driver.find_element(By.LINK_TEXT        ,target[len("link="):]    )
    if target.startswith("partLink="): return self.driver.find_element(By.PARTIAL_LINK_TEXT,target[len("partLink="):])
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'

  def findElements (self,target=""):
    if target.startswith("xpath="):    return self.driver.find_elements(By.XPATH            ,target[len("xpath="):]   )
    if target.startswith("tag="):      return self.driver.find_elements(By.TAG_NAME         ,target[len("tag="):]     )
    if target.startswith("class="):    return self.driver.find_elements(By.CLASS_NAME       ,target[len("class="):]   )
    if target.startswith("id="):       return self.driver.find_elements(By.ID               ,target[len("id="):]      )
    if target.startswith("name="):     return self.driver.find_elements(By.NAME             ,target[len("name="):]    )
    if target.startswith("css="):      return self.driver.find_elements(By.CSS_SELECTOR     ,target[len("css="):]     )
    if target.startswith("link="):     return self.driver.find_elements(By.LINK_TEXT        ,target[len("link="):]    )
    if target.startswith("partLink="): return self.driver.find_elements(By.PARTIAL_LINK_TEXT,target[len("partLink="):])
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'

  def findDedicatedElement (self,element:WebElement = None,target=""):
    if target.startswith("xpath="):    return element.find_element(By.XPATH            ,target[len("xpath="):]   )
    if target.startswith("tag="):      return element.find_element(By.TAG_NAME         ,target[len("tag="):]     )
    if target.startswith("class="):    return element.find_element(By.CLASS_NAME       ,target[len("class="):]   )
    if target.startswith("id="):       return element.find_element(By.ID               ,target[len("id="):]      )
    if target.startswith("name="):     return element.find_element(By.NAME             ,target[len("name="):]    )
    if target.startswith("css="):      return element.find_element(By.CSS_SELECTOR     ,target[len("css="):]     )
    if target.startswith("link="):     return element.find_element(By.LINK_TEXT        ,target[len("link="):]    )
    if target.startswith("partLink="): return element.find_element(By.PARTIAL_LINK_TEXT,target[len("partLink="):])
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'

  def findDedicatedElements (self,element:WebElement = None,target=""):
    if target.startswith("xpath="):    return element.find_elements(By.XPATH            ,target[len("xpath="):]   )
    if target.startswith("tag="):      return element.find_elements(By.TAG_NAME         ,target[len("tag="):]     )
    if target.startswith("class="):    return element.find_elements(By.CLASS_NAME       ,target[len("class="):]   )
    if target.startswith("id="):       return element.find_elements(By.ID               ,target[len("id="):]      )
    if target.startswith("name="):     return element.find_elements(By.NAME             ,target[len("name="):]    )
    if target.startswith("css="):      return element.find_elements(By.CSS_SELECTOR     ,target[len("css="):]     )
    if target.startswith("link="):     return element.find_elements(By.LINK_TEXT        ,target[len("link="):]    )
    if target.startswith("partLink="): return element.find_elements(By.PARTIAL_LINK_TEXT,target[len("partLink="):])
    logger.error("DON'T SUPPORT YOUR TYPE OF TARGET")
    raise ValueError  # shorthand for 'raise ValueError()'
  
  def __printCmdDes (self,command="",description="",printCmd=True):
    if description != "": description = "//"+description
    if self.printOutEna == True and self.printOutLevel == "Fatal"   : logger.fatal("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Error"   : logger.error("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Warn"    : logger.warn ("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Info"    : logger.info ("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Debug"   : logger.debug("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Trace"   : logger.trace("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "Terminal": print ("%s %s",command,description)
    if self.printOutEna == True and self.printOutLevel == "NoPrint" : return
    
  def __shiftInputValue (self,element,target,value,description,printCmd):
    if type(element) != WebElement:
      returnElement     = None
      returnTarget      = element
      returnValue       = target
      returnDescription = value
      returnPrintCmd    = description
    else:
      returnElement     = element
      returnTarget      = target
      returnValue       = value
      returnDescription = description
      returnPrintCmd    = printCmd
   
    print(returnElement)
    print(returnTarget)
    print(returnValue)
    print(returnDescription)
    print(returnPrintCmd)
    return returnElement,returnTarget,returnValue,returnDescription,returnPrintCmd
      
